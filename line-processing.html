<!doctypehtml><html class="sidebar-visible no-js light"lang=en><head><meta charset=UTF-8><title>Line processing - Ruby One-Liners Guide</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta content="Example based guide for text processing with Ruby from the command line"name=description><meta content=width=device-width,initial-scale=1 name=viewport><meta content=#ffffff name=theme-color><meta content="Ruby One-Liners Guide"property=og:title><meta content=website property=og:type><meta content="Example based guide for text processing with Ruby from the command line"property=og:description><meta content=https://learnbyexample.github.io/learn_ruby_oneliners/ property=og:url><meta content=https://raw.githubusercontent.com/learnbyexample/learn_ruby_oneliners/master/images/ruby_oneliners_ls.png property=og:image><meta content=1280 property=og:image:width><meta content=720 property=og:image:height><meta content=summary_large_image property=twitter:card><meta content=@learn_byexample property=twitter:site><link href=favicon.svg rel=icon><link rel="shortcut icon"href=favicon.png><link href=css/variables.css rel=stylesheet><link href=css/general.css rel=stylesheet><link href=css/chrome.css rel=stylesheet><link href=FontAwesome/css/font-awesome.css rel=stylesheet><link href=fonts/fonts.css rel=stylesheet><link href=highlight.css rel=stylesheet><link href=tomorrow-night.css rel=stylesheet><link href=ayu-highlight.css rel=stylesheet><link href=style.css rel=stylesheet><body><script>var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";</script><script>try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }</script><script>var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');</script><script>var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);</script><nav aria-label="Table of contents"class=sidebar id=sidebar><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded"><a href=preface.html><strong aria-hidden=true>1.</strong> Preface</a><li class="chapter-item expanded"><a href=one-liner-introduction.html><strong aria-hidden=true>2.</strong> One-liner introduction</a><li class="chapter-item expanded"><a class=active href=line-processing.html><strong aria-hidden=true>3.</strong> Line processing</a><li class="chapter-item expanded"><a href=field-separators.html><strong aria-hidden=true>4.</strong> Field separators</a><li class="chapter-item expanded"><a href=record-separators.html><strong aria-hidden=true>5.</strong> Record separators</a><li class="chapter-item expanded"><a href=multiple-file-input.html><strong aria-hidden=true>6.</strong> Multiple file input</a><li class="chapter-item expanded"><a href=processing-multiple-records.html><strong aria-hidden=true>7.</strong> Processing multiple records</a><li class="chapter-item expanded"><a href=two-file-processing.html><strong aria-hidden=true>8.</strong> Two file processing</a><li class="chapter-item expanded"><a href=dealing-with-duplicates.html><strong aria-hidden=true>9.</strong> Dealing with duplicates</a><li class="chapter-item expanded"><a href=processing-structured-data.html><strong aria-hidden=true>10.</strong> Processing structured data</a><li class="chapter-item expanded"><a href=Exercise_solutions.html><strong aria-hidden=true>11.</strong> Exercise Solutions</a></li><br><hr><li class="chapter-item expanded"><i class="fa fa-github"id=git-repository-button></i><a href=https://github.com/learnbyexample/learn_ruby_oneliners>   Source code</a><li class="chapter-item expanded"><i class="fa fa-home"id=home-button></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i class="fa fa-book"id=book-button></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i class="fa fa-envelope"id=mail-button></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a><li class="chapter-item expanded"><i class="fa fa-twitter"id=twitter-button></i><a href=https://twitter.com/learn_byexample>   Twitter</a></ol></div><div class=sidebar-resize-handle id=sidebar-resize-handle></div></nav><div class=page-wrapper id=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div class="menu-bar sticky bordered"id=menu-bar><div class=left-buttons><button aria-label="Toggle Table of Contents"title="Toggle Table of Contents"aria-controls=sidebar class=icon-button id=sidebar-toggle type=button><i class="fa fa-bars"></i></button><button aria-label="Change theme"title="Change theme"aria-controls=theme-list aria-expanded=false aria-haspopup=true class=icon-button id=theme-toggle type=button><i class="fa fa-paint-brush"></i></button><ul aria-label=Themes class=theme-popup id=theme-list role=menu><li role=none><button class=theme id=light role=menuitem>Light (default)</button><li role=none><button class=theme id=rust role=menuitem>Rust</button><li role=none><button class=theme id=coal role=menuitem>Coal</button><li role=none><button class=theme id=navy role=menuitem>Navy</button><li role=none><button class=theme id=ayu role=menuitem>Ayu</button></ul><button aria-label="Toggle Searchbar"title="Search. (Shortkey: s)"aria-controls=searchbar aria-expanded=false aria-keyshortcuts=S class=icon-button id=search-toggle type=button><i class="fa fa-search"></i></button></div><h1 class=menu-title>Ruby One-Liners Guide</h1><div class=right-buttons><a aria-label=Blog href=https://learnbyexample.github.io title=Blog> <i class="fa fa-home"id=home-button></i> </a><a aria-label=Twitter href=https://twitter.com/learn_byexample title=Twitter> <i class="fa fa-twitter"id=twitter-button></i> </a><a aria-label="Git repository"title="Git repository"href=https://github.com/learnbyexample/learn_ruby_oneliners> <i class="fa fa-github"id=git-repository-button></i> </a></div></div><div class=hidden id=search-wrapper><form class=searchbar-outer id=searchbar-outer><input placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header id=searchbar name=searchbar type=search></form><div class="searchresults-outer hidden"id=searchresults-outer><div class=searchresults-header id=searchresults-header></div><ul id=searchresults></ul></div></div><script>document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });</script><div class=content id=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=line-processing><a class=header href=#line-processing>Line processing</a></h1><p>Now that you are familiar with basic Ruby CLI usage, this chapter will dive deeper into line processing examples. You'll learn various ways for matching lines based on regular expressions, fixed string matching, line numbers, etc. You'll also see how to group multiple statements and learn about the control flow keywords <code>next</code> and <code>exit</code>.<blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_ruby_oneliners/tree/master/example_files>example_files</a> directory has all the files used in the examples.</blockquote><h2 id=regexp-based-filtering><a class=header href=#regexp-based-filtering>Regexp based filtering</a></h2><p>As mentioned before, in a conditional context:<ul><li><code>/regexp/</code> is a shortcut for <code>$_ =~ /regexp/</code><li><code>!/regexp/</code> is a shortcut for <code>$_ !~ /regexp/</code></ul><p>Here are some examples:<pre><code class=language-bash>$ cat table.txt
brown bread mat hair 42
blue cake mug shirt -7
yellow banana window shoes 3.14

$ ruby -ne 'print if /-|ow\b/' table.txt
blue cake mug shirt -7
yellow banana window shoes 3.14

$ ruby -ne 'print if !/[ksy]/' table.txt
brown bread mat hair 42
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> But, this is not applicable for all types of expressions. For example:<pre><code class=language-bash># /at$/ will be 'true' as it is treated as just a Regexp object here
$ printf 'gate\napple\nwhat\n' | ruby -ne '/at$/ && print'
gate
apple
what

# same as: ruby -ne 'print if /at$/'
$ printf 'gate\napple\nwhat\n' | ruby -ne '$_ =~ /at$/ && print'
what
</code></pre></blockquote><p>If required, you can also use different delimiters with <code>%r</code>. See <a href=https://ruby-doc.org/3.3.0/syntax/literals_rdoc.html#label-25r-3A+Regexp+Literals>ruby-doc: %r Regexp Literals</a> for details.<pre><code class=language-bash>$ cat paths.txt
/home/joe/report.log
/home/ram/power.log
/home/rambo/errors.log

# leaning toothpick syndrome
$ ruby -ne 'print if /\/home\/ram\//' paths.txt
/home/ram/power.log

$ ruby -ne 'print if %r{/home/ram/}' paths.txt
/home/ram/power.log

$ ruby -ne 'print if !%r#/home/ram/#' paths.txt
/home/joe/report.log
/home/rambo/errors.log
</code></pre><h2 id=extracting-matched-portions><a class=header href=#extracting-matched-portions>Extracting matched portions</a></h2><p>You can use regexp related global variables to extract only the matching portions. Consider this input file.<pre><code class=language-bash>$ cat ip.txt
it is a warm and cozy day
listen to what I say
go play in the park
come back before the sky turns dark

There are so many delights to cherish
Apple, Banana and Cherry
Bread, Butter and Jelly
Try them all before you perish
</code></pre><p>Here are some examples of extracting only the matched portions.<pre><code class=language-bash># note that this will print only the first match for each input line
$ ruby -ne 'puts $& if /\b[a-z]\w*[ty]\b/' ip.txt
it
what
play
sky
many

# extract the capture group portions
$ ruby -ne 'puts "#{$1}::#{$2}" if /(\b[bdp]\w+).*(\b[a-f]\w+)/i' ip.txt
back::dark
delights::cherish
Banana::Cherry
Bread::and
</code></pre><blockquote><p><img alt=info src=images/info.svg> See the <a href=https://learnbyexample.github.io/Ruby_Regexp/working-with-matched-portions.html>Working with matched portions</a> chapter from my ebook for examples that use the <code>match</code> method and regexp global variables.</blockquote><h2 id=match-method><a class=header href=#match-method>match? method</a></h2><p>As seen in the previous section, using <code>$_ =~ /regexp/</code> also sets global variables. If you just need a <code>true</code> or <code>false</code> result, using the <code>match?</code> method is better suited for performance reasons. The difference would be more visible for large input files.<pre><code class=language-bash># same result as: ruby -ne 'print if /[AB]|the\b/'
$ ruby -ne 'print if $_.match?(/[AB]|the\b/)' ip.txt
go play in the park
come back before the sky turns dark
Apple, Banana and Cherry
Bread, Butter and Jelly
</code></pre><h2 id=transliteration><a class=header href=#transliteration>Transliteration</a></h2><p>The transliteration method <code>tr</code> helps you perform transformations character-wise. See <a href=https://ruby-doc.org/3.3.0/String.html#method-i-tr>ruby-doc: tr</a> for documentation.<pre><code class=language-bash># rot13
$ echo 'Uryyb Jbeyq' | ruby -pe '$_.tr!("a-zA-Z", "n-za-mN-ZA-M")'
Hello World

# ^ at the start of the first argument complements the specified characters
$ echo 'apple:123:banana' | ruby -pe '$_.tr!("^0-9\n", "-")'
------123-------

# an empty second argument deletes the specified characters
$ echo 'apple:123:banana' | ruby -pe '$_.tr!("^0-9\n", "")'
123

# if the second list is shorter than the number of characters in the first list,
# the last character in the second list will be used to fill the gaps
$ s='orange apple appleseed cab'
$ echo "$s" | ruby -pe 'gsub(/\b(?!apple\b)\w++/) {$&.tr("a-z", "1-9")}'
991975 apple 199959554 312
</code></pre><p>You can use the <code>tr_s</code> method to squeeze repeated characters.<pre><code class=language-bash>$ echo 'APPLESEED gobbledygook' | ruby -pe '$_.tr_s!("a-zA-Z", "a-zA-Z")'
APLESED gobledygok

# transliteration as well as squeeze
$ echo 'APPLESEED gobbledygook' | ruby -pe '$_.tr_s!("A-Z", "a-z")'
aplesed gobbledygook
</code></pre><h2 id=conditional-substitution><a class=header href=#conditional-substitution>Conditional substitution</a></h2><p>These examples combine line filtering and substitution in different ways. As noted before, the <code>sub</code> and <code>gsub</code> Kernel methods update <code>$_</code> if the substitution succeeds and always return the value of <code>$_</code>.<pre><code class=language-bash># change commas to hyphens if the input line does NOT contain '2'
# prints all input lines even if the substitution fails
$ printf '1,2,3,4\na,b,c,d\n' | ruby -pe 'gsub(/,/, "-") if !/2/'
1,2,3,4
a-b-c-d

# perform substitution only for the filtered lines
# prints filtered input lines, even if the substitution fails
$ ruby -ne 'print gsub(/ark/, "[\\0]") if /the/' ip.txt
go play in the p[ark]
come back before the sky turns d[ark]
Try them all before you perish

# print only if the substitution succeeds
# $_.gsub! is required for this scenario
$ ruby -ne 'print if $_.gsub!(/\bw\w*t\b/, "{\\0}")' ip.txt
listen to {what} I say
</code></pre><h2 id=multiple-conditions><a class=header href=#multiple-conditions>Multiple conditions</a></h2><p>It is good to remember that Ruby is a programming language. You can make use of control structures and combine multiple conditions using logical operators, methods like <code>all?</code>, <code>any?</code>, etc. You don't have to create a single complex regexp.<pre><code class=language-bash>$ ruby -ne 'print if /ark/ && !/sky/' ip.txt
go play in the park

$ ruby -ane 'print if /\bthe\b/ || $F.size == 5' ip.txt
listen to what I say
go play in the park
come back before the sky turns dark
</code></pre><h2 id=next><a class=header href=#next>next</a></h2><p>When the <code>next</code> statement is executed, rest of the code will be skipped and the next input line will be fetched for processing. It doesn't affect the <code>BEGIN</code> and <code>END</code> blocks as they are outside the file content loop.<pre><code class=language-bash>$ ruby -ne '(puts "%% #{$_}"; next) if /\bpar/;
            puts /s/ ? "X" : "Y"' word_anchors.txt
%% sub par
X
Y
X
%% cart part tart mart
</code></pre><blockquote><p><img alt=info src=images/info.svg> <code>()</code> is used in the above example to group multiple statements to be executed for a single <code>if</code> condition. You'll see more such examples in the coming chapters.</blockquote><h2 id=exit><a class=header href=#exit>exit</a></h2><p>The <code>exit</code> method will cause the Ruby script to terminate immediately. This is useful to avoid processing unnecessary input content after a termination condition is reached.<pre><code class=language-bash># quits after an input line containing 'say' is found
$ ruby -ne 'print; exit if /say/' ip.txt
it is a warm and cozy day
listen to what I say

# the matching line won't be printed in this case
$ ruby -pe 'exit if /say/' ip.txt
it is a warm and cozy day
</code></pre><p>Use <code>tac</code> to get all lines starting from the last occurrence of the search string in the entire file.<pre><code class=language-bash>$ tac ip.txt | ruby -ne 'print; exit if /an/' | tac
Bread, Butter and Jelly
Try them all before you perish
</code></pre><p>You can optionally provide a status code as an argument to the <code>exit</code> method.<pre><code class=language-bash>$ printf 'sea\neat\ndrop\n' | ruby -ne 'print; exit(2) if /at/'
sea
eat
$ echo $?
2
</code></pre><p>Any code in the <code>END</code> block will still be executed before exiting. This doesn't apply if <code>exit</code> was called from the <code>BEGIN</code> block.<pre><code class=language-bash>$ ruby -pe 'exit if /cake/' table.txt
brown bread mat hair 42

$ ruby -pe 'exit if /cake/; END{puts "bye"}' table.txt
brown bread mat hair 42
bye

$ ruby -pe 'BEGIN{puts "hi"; exit; puts "hello"}; END{puts "bye"}' table.txt
hi
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> Be careful if you want to use <code>exit</code> with multiple input files, as Ruby will stop even if there are other files remaining to be processed.</blockquote><h2 id=line-number-based-processing><a class=header href=#line-number-based-processing>Line number based processing</a></h2><p>Line numbers can also be specified as a matching criteria by using the <code>$.</code> global variable.<pre><code class=language-bash># print only the third line
$ ruby -ne 'print if $. == 3' ip.txt
go play in the park

# print the second and sixth lines
$ ruby -ne 'print if $. == 2 || $. == 6' ip.txt
listen to what I say
There are so many delights to cherish

# transliterate only the second line
$ printf 'gates\nnot\nused\n' | ruby -pe '$_.tr!("a-z", "*") if $. == 2'
gates
***
used

# print from a particular line number to the end of the input
$ seq 14 25 | ruby -ne 'print if $. >= 10'
23
24
25
</code></pre><p>The global variable <code>$<</code> contains the file handle for the current file input being processed. Use the <code>eof</code> method to check for the end of the file condition. See <a href=https://ruby-doc.org/3.3.0/IO.html#method-i-eof>ruby-doc: eof</a> for documentation. You can also use <code>ARGF</code> instead of <code>$<</code> here, see the <a href=./multiple-file-input.html#argv-and-argf>ARGV and ARGF</a> section for details.<pre><code class=language-bash># same as: tail -n1 ip.txt
$ ruby -ne 'print if $<.eof' ip.txt
Try them all before you perish

$ ruby -ne 'puts "#{$.}:#{$_}" if $<.eof' ip.txt
9:Try them all before you perish

# multiple file example
# same as: tail -q -n1 ip.txt table.txt
$ ruby -ne 'print if $<.eof' ip.txt table.txt
Try them all before you perish
yellow banana window shoes 3.14
</code></pre><p>For large input files, use the <code>exit</code> method to avoid processing unnecessary input lines.<pre><code class=language-bash>$ seq 3542 4623452 | ruby -ne '(print; exit) if $. == 2452'
5993

$ seq 3542 4623452 | ruby -ne 'print if $. == 250; (print; exit) if $. == 2452'
3791
5993

# here is a sample time comparison
$ time seq 3542 4623452 | ruby -ne '(print; exit) if $. == 2452' > f1
real    0m0.055s
$ time seq 3542 4623452 | ruby -ne 'print if $. == 2452' > f2
real    0m1.130s
$ rm f1 f2
</code></pre><h2 id=flip-flop-operator><a class=header href=#flip-flop-operator>Flip-Flop operator</a></h2><p>You can use the Flip-Flop operator to select between a pair of matching conditions like line numbers and regexp. See <a href=https://ruby-doc.org/3.3.0/syntax/control_expressions_rdoc.html#label-Flip-Flop>ruby-doc: Flip-Flop</a> for documentation.<pre><code class=language-bash># the range is automatically compared against $. in this context
$ seq 14 25 | ruby -ne 'print if 3..5'
16
17
18

# 'print if 3...5' gives the same result as above,
# you can use the include? method to exclude the end range
$ seq 14 25 | ruby -ne 'print if (3...5).include?($.)'
16
17

# the range is automatically compared against $_ in this context
# note that all the matching ranges are printed
$ ruby -ne 'print if /to/../pl/' ip.txt
listen to what I say
go play in the park
There are so many delights to cherish
Apple, Banana and Cherry
</code></pre><blockquote><p><img alt=info src=images/info.svg> See the <a href=./processing-multiple-records.html#records-bounded-by-distinct-markers>Records bounded by distinct markers</a> section for an alternate solution.</blockquote><p>Line numbers and regexp filtering can be mixed.<pre><code class=language-bash>$ ruby -ne 'print if 6../utter/' ip.txt
There are so many delights to cherish
Apple, Banana and Cherry
Bread, Butter and Jelly

# same logic as: ruby -pe 'exit if /\bba/'
# inefficient, but this will work for multiple file inputs
$ ruby -ne 'print if !(/\bba/..$<.eof)' ip.txt table.txt
it is a warm and cozy day
listen to what I say
go play in the park
brown bread mat hair 42
blue cake mug shirt -7
</code></pre><p>Both conditions can match the same line too! Also, if the second condition doesn't match, lines starting from the first condition to the last line of the input will be matched.<pre><code class=language-bash># 'and' matches the 7th line
$ ruby -ne 'print if 7../and/' ip.txt
Apple, Banana and Cherry
# 'and' will be tested against 8th line onwards
$ ruby -ne 'print if 7.../and/' ip.txt
Apple, Banana and Cherry
Bread, Butter and Jelly

# there's a line containing 'Banana' but the matching pair isn't found
# so, all lines till the end of the input is printed
$ ruby -ne 'print if /Banana/../XYZ/' ip.txt
Apple, Banana and Cherry
Bread, Butter and Jelly
Try them all before you perish
</code></pre><h2 id=working-with-fixed-strings><a class=header href=#working-with-fixed-strings>Working with fixed strings</a></h2><p>To match strings literally, use the <code>include?</code> method for line filtering. Use string argument instead of regexp for fixed string matching with substitution methods.<pre><code class=language-bash>$ printf 'int a[5]\nfig\n1+4=5\n' | ruby -ne 'print if /a[5]/'
$ printf 'int a[5]\nfig\n1+4=5\n' | ruby -ne 'print if $_.include?("a[5]")'
int a[5]

$ printf 'int a[5]\nfig\n1+4=5\n' | ruby -pe 'sub(/a[5]/, "b")'
int a[5]
fig
1+4=5
$ printf 'int a[5]\nfig\n1+4=5\n' | ruby -pe 'sub("a[5]", "b")'
int b
fig
1+4=5
</code></pre><p>The above examples use double quotes for the string argument, which allows escape sequences like <code>\t</code>, <code>\n</code>, etc and interpolation with <code>#{}</code>. This isn't the case with single quoted string values. Using single quotes within the script from the command line requires messing with shell metacharacters. So, use <code>%q</code> instead or pass the fixed string to be matched as an environment variable.<pre><code class=language-bash># double quotes allow escape sequences and interpolation
$ ruby -e 'a=5; puts "value of a:\t#{a}"'
value of a:     5

# use %q as an alternate to specify single quoted strings
$ echo 'int #{a}' | ruby -ne 'print if $_.include?(%q/#{a}/)'
int #{a}
$ echo 'int #{a}' | ruby -pe 'sub(%q/#{a}/, "b")'
int b

# or pass the string as an environment variable
$ echo 'int #{a}' | s='#{a}' ruby -ne 'print if $_.include?(ENV["s"])'
int #{a}
# \\ is special within single quotes, so ENV is the better choice here
$ echo 'int #{a\\}' | s='#{a\\}' ruby -pe 'sub(ENV["s"], "b")'
int b
</code></pre><p>To provide a fixed string in the replacement section, environment variables comes in handy again. Need to use block form, since <code>\</code> is special in the replacement section.<pre><code class=language-bash># \\ will be treated as \ and \0 will backreference the entire matched portion
$ echo 'int a' | s='x\\y\0z' ruby -pe 'sub(/a/, ENV["s"])'
int x\yaz

# use block form to avoid such issues
$ echo 'int a' | s='x\\y\0z' ruby -pe 'sub(/a/) {ENV["s"]}'
int x\\y\0z
</code></pre><p>Use the <code>start_with?</code> and <code>end_with?</code> methods to restrict the matching to the start or end of the input line. The line content in the <code>$_</code> variable contains the <code>\n</code> line ending character as well. You can either use the <code>chomp</code> method explicitly or use the <code>-l</code> command line option (which will be discussed in detail in the <a href=./record-separators.html#record-separators>Record separators</a> chapter). For now, it is enough to know that <code>-l</code> will remove the line separator and add it back when <code>print</code> is used.<pre><code class=language-bash>$ cat eqns.txt
a=b,a-b=c,c*d
a+b,pi=3.14,5e12
i*(t+9-g)/8,4-a+b

# start of the line
$ s='a+b' ruby -ne 'print if $_.start_with?(ENV["s"])' eqns.txt
a+b,pi=3.14,5e12

# end of the line
# -l option is needed here to remove \n from $_
$ s='a+b' ruby -lne 'print if $_.end_with?(ENV["s"])' eqns.txt
i*(t+9-g)/8,4-a+b
</code></pre><p>Use the <code>index</code> method if you need more control over the location of the matching strings. You can use either the return value (which gives you the index of the matching string) or use the optional second argument to specify an offset to start searching. See <a href=https://ruby-doc.org/3.3.0/String.html#method-i-index>ruby-doc: index</a> for details.<pre><code class=language-bash># same as: $_.include?("a+b")
$ ruby -ne 'print if $_.index("a+b")' eqns.txt
a+b,pi=3.14,5e12
i*(t+9-g)/8,4-a+b

# same as: $_.start_with?("a+b")
$ ruby -ne 'print if $_.index("a+b")==0' eqns.txt
a+b,pi=3.14,5e12

# since 'index' returns 'nil' if there's no match,
# you need some more processing for < or <= comparison
$ ruby -ne '$i = $_.index("="); print if $i && $i < 6' eqns.txt
a=b,a-b=c,c*d

# for > or >= comparison, use the optional second argument
$ s='a+b' ruby -ne 'print if $_.index(ENV["s"], 1)' eqns.txt
i*(t+9-g)/8,4-a+b
</code></pre><p>If you need to match the entire input line or a particular field, you can use the comparison operators.<pre><code class=language-bash>$ printf 'a.b\na+b\n' | ruby -lne 'print if /^a.b$/'
a.b
a+b
$ printf 'a.b\na+b\n' | ruby -lne 'print if $_ == %q/a.b/'
a.b

$ printf '1 a.b\n2 a+b\n' | ruby -lane 'print if $F[1] != %q/a.b/'
2 a+b
</code></pre><h2 id=in-place-file-editing><a class=header href=#in-place-file-editing>In-place file editing</a></h2><p>You can use the <code>-i</code> option to write back the changes to the input file instead of displaying the output on terminal. When an extension is provided as an argument to <code>-i</code>, the original contents of the input file gets preserved as per the extension given. For example, if the input file is <code>ip.txt</code> and <code>-i.orig</code> is used, the backup file will be named as <code>ip.txt.orig</code>.<pre><code class=language-bash>$ cat colors.txt
deep blue
light orange
blue delight

# no output on the terminal as -i option is used
# space is NOT allowed between -i and the extension
$ ruby -i.bkp -pe 'sub(/blue/, "-green-")' colors.txt
# changes are written back to 'colors.txt'
$ cat colors.txt
deep -green-
light orange
-green- delight

# original file is preserved in 'colors.txt.bkp'
$ cat colors.txt.bkp
deep blue
light orange
blue delight
</code></pre><p>Multiple input files are treated individually and the changes are written back to respective files.<pre><code class=language-bash>$ cat t1.txt
have a nice day
bad morning
what a pleasant evening
$ cat t2.txt
worse than ever
too bad

$ ruby -i.bkp -pe 'sub(/bad/, "good")' t1.txt t2.txt
$ ls t?.*
t1.txt  t1.txt.bkp  t2.txt  t2.txt.bkp

$ cat t1.txt
have a nice day
good morning
what a pleasant evening
$ cat t2.txt
worse than ever
too good
</code></pre><p>Sometimes backups are not desirable. In such cases, you can use the <code>-i</code> option without an argument. Be careful though, as changes made cannot be undone. It is recommended to test the command with sample inputs before applying the <code>-i</code> option on the actual file. You could also use the option with backup, compare the differences with a <code>diff</code> program and then delete the backup.<pre><code class=language-bash>$ cat fruits.txt
banana
papaya
mango

$ ruby -i -pe 'gsub(/(..)\1/) {$&.upcase}' fruits.txt
$ cat fruits.txt
bANANa
PAPAya
mango
</code></pre><h2 id=summary><a class=header href=#summary>Summary</a></h2><p>This chapter showed various examples of processing only the lines of interest instead of the entire input file. Filtering can be specified using a regexp, fixed string, line number or a combination of them. You also saw how to combine multiple statements inside <code>()</code> for compact CLI usage. The <code>next</code> and <code>exit</code> methods are useful to control the flow of code. The <code>-i</code> option is handy for in-place editing.<h2 id=exercises><a class=header href=#exercises>Exercises</a></h2><blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_ruby_oneliners/tree/master/exercises>exercises</a> directory has all the files used in this section.</blockquote><p><strong>1)</strong> For the given input, display except the third line.<pre><code class=language-bash>$ seq 34 37 | ##### add your solution here
34
35
37
</code></pre><p><strong>2)</strong> Display only the fourth, fifth, sixth and seventh lines for the given input.<pre><code class=language-bash>$ seq 65 78 | ##### add your solution here
68
69
70
71
</code></pre><p><strong>3)</strong> For the input file <code>ip.txt</code>, replace all occurrences of <code>are</code> with <code>are not</code> and <code>is</code> with <code>is not</code> only from line number <strong>4</strong> till the end of file. Also, only the lines that were changed should be displayed in the output.<pre><code class=language-bash>$ cat ip.txt
Hello World
How are you
This game is good
Today is sunny
12345
You are funny

##### add your solution here
Today is not sunny
You are not funny
</code></pre><p><strong>4)</strong> For the given stdin, display only the first three lines. Avoid processing lines that are not relevant.<pre><code class=language-bash>$ seq 14 25 | ##### add your solution here
14
15
16
</code></pre><p><strong>5)</strong> For the input file <code>ip.txt</code>, display all lines from the start of the file till the first occurrence of <code>game</code>.<pre><code class=language-bash>##### add your solution here
Hello World
How are you
This game is good
</code></pre><p><strong>6)</strong> For the input file <code>ip.txt</code>, display all lines that contain <code>is</code> but not <code>good</code>.<pre><code class=language-bash>##### add your solution here
Today is sunny
</code></pre><p><strong>7)</strong> For the input file <code>ip.txt</code>, extract the word before the whole word <code>is</code> as well as the word after it. If such a match is found, display the two words around <code>is</code> in reversed order. For example, <code>hi;1 is--234 bye</code> should be converted to <code>234:1</code>. Assume that the whole word <code>is</code> will not be present more than once in a single line.<pre><code class=language-bash>##### add your solution here
good:game
sunny:Today
</code></pre><p><strong>8)</strong> For the input file <code>hex.txt</code>, replace all occurrences of <code>0xA0</code> with <code>0x50</code> and <code>0xFF</code> with <code>0x7F</code>.<pre><code class=language-bash>$ cat hex.txt
start: 0xA0, func1: 0xA0
end: 0xFF, func2: 0xB0
restart: 0xA010, func3: 0x7F

##### add your solution here
start: 0x50, func1: 0x50
end: 0x7F, func2: 0xB0
restart: 0x5010, func3: 0x7F
</code></pre><p><strong>9)</strong> For the input file <code>text.txt</code>, replace all occurrences of <code>in</code> with <code>an</code> and write back the changes to <code>text.txt</code> itself. The original contents should get saved to <code>text.txt.orig</code>.<pre><code class=language-bash>$ cat text.txt
can ran want plant
tin fin fit mine line

##### add your solution here

$ cat text.txt
can ran want plant
tan fan fit mane lane
$ cat text.txt.orig
can ran want plant
tin fin fit mine line
</code></pre><p><strong>10)</strong> For the input file <code>text.txt</code>, replace all occurrences of <code>an</code> with <code>in</code> and write back the changes to <code>text.txt</code> itself. Do not create backups for this exercise. Note that you should have solved the previous exercise before starting this one.<pre><code class=language-bash>$ cat text.txt
can ran want plant
tan fan fit mane lane

##### add your solution here

$ cat text.txt
cin rin wint plint
tin fin fit mine line
$ diff text.txt text.txt.orig
1c1
< cin rin wint plint
---
> can ran want plant
</code></pre><p><strong>11)</strong> Find the starting index of first occurrence of <code>is</code> or <code>the</code> or <code>was</code> or <code>to</code> for each input line of the file <code>idx.txt</code>. Assume that every input line will match at least one of these terms.<pre><code class=language-bash>$ cat idx.txt
match after the last newline character
and then you want to test
this is good bye then
you were there to see?

##### add your solution here
12
4
2
9
</code></pre><p><strong>12)</strong> Display all lines containing <code>[4]*</code> for the given stdin data.<pre><code class=language-bash>$ printf '2.3/[4]*6\n2[4]5\n5.3-[4]*9\n' | ##### add your solution here
2.3/[4]*6
5.3-[4]*9
</code></pre><p><strong>13)</strong> For the given input string, change all lowercase alphabets to <code>x</code> only for words starting with <code>m</code>.<pre><code class=language-bash>$ s='ma2T3a a2p kite e2e3m meet'

$ echo "$s" | ##### add your solution here
xx2T3x a2p kite e2e3m xxxx
</code></pre><p><strong>14)</strong> For the input file <code>ip.txt</code>, delete all characters other than lowercase vowels and the newline character. Perform this transformation only between a line containing <code>you</code> up to line number <code>4</code> (inclusive).<pre><code class=language-bash>##### add your solution here
Hello World
oaeou
iaeioo
oaiu
12345
You are funny
</code></pre><p><strong>15)</strong> For the input file <code>sample.txt</code>, display from the start of the file till the first occurrence of <code>are</code>, excluding the matching line.<pre><code class=language-bash>$ cat sample.txt
Hello World

Good day
How are you

Just do-it
Believe it

Today is sunny
Not a bit funny
No doubt you like it too

Much ado about nothing
He he he

##### add your solution here
Hello World

Good day
</code></pre><p><strong>16)</strong> For the input file <code>sample.txt</code>, display from the last occurrence of <code>do</code> till the end of the file.<pre><code class=language-bash>##### add your solution here
Much ado about nothing
He he he
</code></pre><p><strong>17)</strong> For the input file <code>sample.txt</code>, display from the 9th line till a line containing <code>you</code>.<pre><code class=language-bash>##### add your solution here
Today is sunny
Not a bit funny
No doubt you like it too
</code></pre><p><strong>18)</strong> Display only the odd numbered lines from <code>ip.txt</code>.<pre><code class=language-bash>##### add your solution here
Hello World
This game is good
12345
</code></pre><p><strong>19)</strong> For the <code>table.txt</code> file, print only the line number for lines containing <code>air</code> or <code>win</code>.<pre><code class=language-bash>$ cat table.txt
brown bread mat hair 42
blue cake mug shirt -7
yellow banana window shoes 3.14

##### add your solution here
1
3
</code></pre><p><strong>20)</strong> For the input file <code>table.txt</code>, calculate the sum of numbers in the last column, excluding the second line.<pre><code class=language-bash>##### add your solution here
45.14
</code></pre><p><strong>21)</strong> Print the second and fourth line for every block of five lines.<pre><code class=language-bash>$ seq 15 | ##### add your solution here
2
4
7
9
12
14
</code></pre><p><strong>22)</strong> For the input file <code>ip.txt</code>, display all lines containing <code>e</code> or <code>u</code> but not both.<pre><code class=language-bash>##### add your solution here
Hello World
This game is good
Today is sunny
</code></pre></main><nav aria-label="Page navigation"class=nav-wrapper><a aria-label="Previous chapter"class="mobile-nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=one-liner-introduction.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="mobile-nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=field-separators.html rel=next> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav aria-label="Page navigation"class=nav-wide-wrapper><a aria-label="Previous chapter"class="nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=one-liner-introduction.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=field-separators.html rel=next> <i class="fa fa-angle-right"></i> </a></nav></div><script>window.playground_copyable = true;</script><script charset=utf-8 src=elasticlunr.min.js></script><script charset=utf-8 src=mark.min.js></script><script charset=utf-8 src=searcher.js></script><script charset=utf-8 src=clipboard.min.js></script><script charset=utf-8 src=highlight.js></script><script charset=utf-8 src=book.js></script><script src=sidebar.js></script>